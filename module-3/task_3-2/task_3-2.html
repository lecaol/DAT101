<!DOCTYPE html>
<html lang="en" style="display: table; margin: auto; zoom: 1">
  <head>
    <meta charset="UTF-8" />
    <title>Task 3.2</title>
  </head>
  <body style="display: table-cell; vertical-align: middle">
    <h2><label for="txtOut">Output from Task 3.2:</label></h2>
    <div style="padding: 10px; min-width: 512px; border: darkblue thin solid; background-color: antiquewhite; font-family: 'Courier New', serif">
      <span id="txtOut" style="white-space: nowrap"></span>
    </div>
    <ol>
      <li>[In part 1, is it possible to solve the problem using a single "for" loop?]</li>
      <p>[Ja, det er mulig. I min besvarelse har jeg brukt 2 for loops: en for å telle oppover til 10 og en for å telle nedover. 
        Men siden koden skal utføre like mange steg kan man sette alt i en løkke. Hvis jeg for eksempel skulle telt fra 1-10 og ned fra 16-1 måtte jeg ha brukt to løkker uansett.
        En måte å gjøre det på er: <br>
        let OnetoTen = ""; <br>
        let TentoOne = ""; <br>
        <br>
        for (let i = 1, j = 10; i &lt;= 15; i++, j--) { <br>
          OnetoTen += i.tostring() + " "; <br>
          TentoOne += j.tostring() + " "; <br>
        } <br>
        printOut(OnetoTen + newLine + TentoOne)] <br>
      I denne for-loopen har man definert to startpunkt: i=1 og j=10. I tillegg til to "oppdateringer": i++ og j--. Det er bare en enkel betingelse som sjekkes:
      i &lt;= 10 som sier at loopen skal fortsette så lenge "i" er mindre enn eller lik 10. Siden nedtellingen utføres like mange ganger som opptellingen trenger man 
      ikke en betingelse for 10-> 1 siden nedtellingen vil stoppe samtidig som opptellingen. Man kunne også skrevet betingelsen j >= 1 sammen med den andre ved hjelp av "&&"
      men det er ikke nødvendig for denne oppgaven.</p>

      <li>[In part 2, can we create what is known as an "infinite" loop within the condition of the "while" loop? Describe what would or
          or would not be necessary to achieve this.]</li>
      <p>[Min kode for del 2 var: <br>
        const number = 45; <br>
        let guess = Math.floor(Math.random() * 60) + 1; <br>
<br>
        while (guess !== number) { <br>
            guess = Math.floor(Math.random() * 60) + 1;<br>
        }<br>
        Koden gir verdien 45 og et tilfeldig tall mellom 1-60. While-loopen sier at så lenge det gjettede tallet "guess" ikke er lik number "45"
        så skal programmet fortsette å gjette. <br>
        En while-løkke vil alltid fortsette så lenge betingelsen er sann. Derfor må vi på en eller annen måte gjøre slik at betingelsen alltid stemmer slik
        at vi får en uendelig while-loop. Enten må vi bytte ut selve betingelsen i loopen, eller så må vi endre variablene utenfor loopen slik at 
        betingelsen i "while"-loopen alltid er sann. Om vi endrer betingelsen kan vi skrive "while (true)" for å gjøre løkken uendelig. Betingelsen "true" vil 
        alltids være sann og løkken vil aldri stoppe. En annen måte er å endre "const number = 45" til for eksempel "0" eller "70". "while"-loopen
        gir et gjett hver gang det gjettede tallet ikke er lik "const number". Samtidig gjetter koden bare tall mellom 1 og 60. Om vi setter variabelen
        til en verdi mindre enn 1 eller større enn 60 vil loopen aldri kunne gjette rett verdi. Derfor vil betingelsen alltid være sann og vi får en uendelig løkke.] </p>
      <li>[Discuss briefly how quickly or slowly a computer might be able to compute this, considering the number of guesses and the time it takes. 
        How does the program behave while it is guessing? Can the program perform other tasks concurrently?]</li>
      <p>[En datamaskin vil kunne gjette tallet veldig raskt. Etter å ha testet koden mange ganger har det høyeste antall gjett jeg har fått vært: "2492013"
        og da brukte programmet 64 millisekunder/0.064 sekunder. Programmet kjøres veldig raskt. I teorien kan det ta relativt lang tid 
        hvis programmet er uheldig og bommer mange ganger på gjettene. Samtidig så skal det mye til for at det i det hele tatt tar mer enn 0.1 sekunder å gjette
        svaret. <br>
        Koden gir et tilfeldig tall helt til det gjetter "45000". Etter hvert gjett sjekker den om betingelsen i løkken er sann eller falsk. Om den er falsk så stopper 
        den å gjette. I dette tilfellet kan ikke programme utføre andre oppgaver samtidig. Javascript er i utgangspunktet "synchronous". Dette vil si at Javascript
        en og en linje med kode om gangen. Den neste linjen med kode kjøres ikke før den forrige er ferdig. Om man ønsker at Javascript skal kjøre "asynchronous" må
        man bruke egne funksjoner som lar programmet gjøre flere ting samtidig. <br>
        Kilder: https://medium.com/better-programming/is-javascript-synchronous-or-asynchronous-what-the-hell-is-a-promise-7aa9dd8f3bfb og chatgpt.] </p>
      <li>[Explain the relationship between rows and columns in nested "for" loops. Can we, for instance, change the order, considering rows to be innermost or
         columns to be innermost, or does this not matter?]</li>
      <p>[I min kode har jeg satt rader i den ytterte løkka og kolonnene i den innerste. Koden lager en rad og deretter lages 9 kolonner med den innerste løkka. 
        Og slik fortsetter det: en ny rad/linje og 9 kolonner per linje. Teknisk sett kan man endre rekkefølgen ved at kolonnene lages i den ytterst løkka og sette
        radene i den innerste, men da vil man få en annen output. Da vil man få 7 kolonner og 9 rader i stedet for omvendt slik det skal være. På grunn av rekkefølgen
        som koden leses i: den innerste løkken gjentar seg selv inni den andre løkken. Så bør radene være ytterst og kolonnene innerst. For hver rad lages det syv kolonner
        og outputen printes ut linje for linje. Derfor må radene være ytterst og kolonnene innerst. ] </p>
        ] </p>
    </ol>
    <script type="module" src="./task_3-2.mjs" defer></script>
  </body>
</html>
